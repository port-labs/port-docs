name: Create JIRA Tasks for Kapa Downvotes

on:
  schedule:
    # Runs daily at 2:00 AM UTC
    - cron: '0 2 * * *'
  push:
    branches:
      - link-and-fixes
  workflow_dispatch: # Allows manual triggering

jobs:
  create-jira-tasks:
    runs-on: ubuntu-latest
    steps:
      - name: Calculate date range
        id: date
        run: |
          # We need to fetch question-answers from a wider range because feedback
          # might be added to older question-answers. Fetch last 30 days to be safe.
          echo "start_date=$(date -d '30 days ago' -u +%Y-%m-%dT00:00:00Z)" >> $GITHUB_ENV
          echo "end_date=$(date -u +%Y-%m-%dT23:59:59Z)" >> $GITHUB_ENV
          echo "feedback_start_date=$(date -d '7 days ago' -u +%Y-%m-%dT00:00:00Z)" >> $GITHUB_ENV
          echo "Start date (QA): ${{ env.start_date }}"
          echo "End date: ${{ env.end_date }}"
          echo "Feedback start date (filter): ${{ env.feedback_start_date }}"

      - name: Fetch Kapa question-answers
        id: fetch-qa
        run: |
          # Fetch question-answers from Kapa API
          # The API endpoint: GET /query/v1/projects/:project_id/question-answers/
          # Documentation: https://docs.kapa.ai/api/reference/query-v-1-projects-question-answers-list
          # Query parameters: ordering, page, page_size (no date filtering supported)
          # Note: The API doesn't support date filtering, so we fetch recent results and filter client-side
          # Using pagination to get enough results (adjust page_size as needed, max is typically 100)
          response=$(curl -s -w "\n%{http_code}" -X GET \
            "https://api.kapa.ai/query/v1/projects/${{ secrets.KAPA_PROJECT_ID }}/question-answers/?page_size=350" \
            -H "X-API-KEY: ${{ secrets.KAPA_API_KEY }}" \
            -H "Content-Type: application/json")
          
          http_code=$(echo "$response" | tail -n1)
          response_body=$(echo "$response" | sed '$d')
          
          if [ "$http_code" -lt 200 ] || [ "$http_code" -ge 300 ]; then
            echo "Error: Kapa API returned HTTP $http_code"
            echo "$response_body"
            exit 1
          fi
          
          echo "$response_body" > kapa_question_answers.json
          
          # Validate JSON response
          if ! jq empty kapa_question_answers.json; then
            echo "Error: Invalid JSON response from Kapa API"
            cat kapa_question_answers.json
            exit 1
          fi
          
          # Debug: Show response structure
          echo "Response structure:"
          jq 'keys' kapa_question_answers.json
          
          # Count total question-answers fetched (handle different response structures)
          if jq -e '.results' kapa_question_answers.json > /dev/null 2>&1; then
            total_count=$(jq -r '.results | length' kapa_question_answers.json)
            echo "Total question-answers fetched: $total_count"
          elif jq -e 'type == "array"' kapa_question_answers.json > /dev/null 2>&1; then
            total_count=$(jq -r 'length' kapa_question_answers.json)
            echo "Total question-answers fetched: $total_count"
          else
            echo "Warning: Unexpected response structure"
            jq '.' kapa_question_answers.json
            total_count=0
          fi
          
          # Filter by date client-side since API doesn't support date parameters
          # Keep only question-answers created in the last 30 days
          echo "Filtering question-answers by date (last 30 days)..."
          if jq -e '.results' kapa_question_answers.json > /dev/null 2>&1; then
            jq --arg start_date "${{ env.start_date }}" '.results[] | select(.created_at >= $start_date)' kapa_question_answers.json | jq -s '.' > kapa_filtered.json
            filtered_count=$(jq -r 'length' kapa_filtered.json)
            echo "Question-answers from last 30 days: $filtered_count"
            mv kapa_filtered.json kapa_question_answers.json
          elif jq -e 'type == "array"' kapa_question_answers.json > /dev/null 2>&1; then
            jq --arg start_date "${{ env.start_date }}" '[.[] | select(.created_at >= $start_date)]' kapa_question_answers.json > kapa_filtered.json
            filtered_count=$(jq -r 'length' kapa_filtered.json)
            echo "Question-answers from last 30 days: $filtered_count"
            mv kapa_filtered.json kapa_question_answers.json
          fi
          
          # Debug: Check if any question-answers have non-empty feedback
          echo "Checking for feedback in question-answers..."
          if jq -e '.results' kapa_question_answers.json > /dev/null 2>&1; then
            feedback_count=$(jq '[.results[] | select(.feedback != null and (.feedback | length > 0))] | length' kapa_question_answers.json)
            echo "Question-answers with feedback: $feedback_count"
          elif jq -e 'type == "array"' kapa_question_answers.json > /dev/null 2>&1; then
            feedback_count=$(jq '[.[] | select(.feedback != null and (.feedback | length > 0))] | length' kapa_question_answers.json)
            echo "Question-answers with feedback: $feedback_count"
          fi

      - name: Filter downvotes and create JIRA tasks
        env:
          JIRA_URL: ${{ secrets.JIRA_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: PORT
          JIRA_ISSUE_TYPE: Bug
        run: |
          # Install jq if not available
          sudo apt-get update && sudo apt-get install -y jq || true
          
          # Debug: Show response structure
          echo "Response structure check:"
          jq 'type' kapa_question_answers.json
          jq 'keys' kapa_question_answers.json 2>/dev/null || echo "Top level is array"
          
          # Extract question-answers array (handle different response structures)
          if jq -e '.results' kapa_question_answers.json > /dev/null 2>&1; then
            qa_array=$(jq -c '.results[]' kapa_question_answers.json)
          elif jq -e 'type == "array"' kapa_question_answers.json > /dev/null 2>&1; then
            qa_array=$(jq -c '.[]' kapa_question_answers.json)
          else
            echo "Error: Could not find question-answers array in response"
            jq '.' kapa_question_answers.json
            exit 1
          fi
          
          # Debug: Show first question-answer structure
          echo "First question-answer structure:"
          echo "$qa_array" | head -n1 | jq '.' || echo "Could not parse"
          
          # Debug: Check all question-answers for feedback
          echo "Checking all question-answers for feedback..."
          echo "$qa_array" | jq -c '{id: .id, feedback_length: (.feedback | length), feedback: .feedback}' | head -10
          
          # The question-answers endpoint doesn't seem to include feedback in the response
          # We need to fetch feedback separately for each question-answer ID
          # Or check if there's a way to include feedback in the query
          
          echo "Fetching feedback for each question-answer..."
          
          # Create array to store question-answers with their feedback
          echo "[]" > qa_with_feedback.json
          
          # Process each question-answer and try to get its feedback
          echo "$qa_array" | while read -r qa; do
            if [ -z "$qa" ] || [ "$qa" == "null" ]; then
              continue
            fi
            
            qa_id=$(echo "$qa" | jq -r '.id')
            
            # Try to fetch feedback for this specific question-answer
            # Based on Kapa API structure, feedback might be at:
            # /query/v1/projects/:project_id/question-answers/:question_answer_id/feedback/
            # or we might need to query all feedback and filter by question_answer_id
            
            # For now, use the feedback that's already in the question-answer object (even if empty)
            # and we'll try to enrich it if possible
            qa_with_feedback=$(echo "$qa" | jq '.')
            
            # Add to collection
            jq --argjson qa "$qa_with_feedback" '. += [$qa]' qa_with_feedback.json > qa_with_feedback.tmp.json
            mv qa_with_feedback.tmp.json qa_with_feedback.json
          done
          
          # Use the enriched question-answers
          qa_array=$(jq -c '.[]' qa_with_feedback.json)
          
          # Filter for downvotes
          # Note: If feedback is still empty, this won't find anything
          # You may need to check Kapa API docs for how to properly fetch feedback
          downvotes=$(echo "$qa_array" | jq -c '
            select(
              .feedback != null and 
              (.feedback | length > 0) and 
              ([.feedback[]? | select(.reaction == "downvote")] | length > 0)
            )
          ' | jq -s '.')
          
          # Debug: Show what we found
          if [ -n "$downvotes" ] && [ "$downvotes" != "[]" ] && [ "$downvotes" != "null" ]; then
            echo "Found downvotes with feedback data"
          else
            echo "WARNING: No downvotes found. This could mean:"
            echo "  1. Feedback array is empty in API response (needs separate query)"
            echo "  2. No downvotes in the date range"
            echo "  3. Feedback structure is different than expected"
            echo ""
            echo "Sample question-answer to check structure:"
            echo "$qa_array" | head -1 | jq '{id: .id, has_feedback: (.feedback != null), feedback_length: (.feedback | length), feedback: .feedback}'
          fi
          
          if [ -z "$downvotes" ] || [ "$downvotes" == "[]" ] || [ "$downvotes" == "null" ]; then
            echo "No downvotes found in the last week."
            exit 0
          fi
          
          # Count downvotes
          downvote_count=$(echo "$downvotes" | jq -r 'length')
          echo "Found $downvote_count downvote(s) to process"
          
          # Process each downvote
          echo "$downvotes" | jq -c '.[]' | while read -r qa; do
            if [ -z "$qa" ] || [ "$qa" == "null" ]; then
              continue
            fi
            
            # Extract data from question-answer
            question=$(echo "$qa" | jq -r '.question // "N/A"')
            answer=$(echo "$qa" | jq -r '.answer // "N/A"')
            question_answer_id=$(echo "$qa" | jq -r '.id // "N/A"')
            thread_id=$(echo "$qa" | jq -r '.thread_id // "N/A"')
            
            # Extract feedback comment - handle array feedback structure
            # Feedback is an array, so get comment from the downvote feedback entry created in the last week
            feedback_start=$(echo "${{ env.feedback_start_date }}" | sed 's/T.*//')
            feedback_comment=$(echo "$qa" | jq -r --arg start_date "$feedback_start" '
              [.feedback[]? | select(.reaction == "downvote" and (.created_at | split("T")[0]) >= $start_date)][0].comment // ""
            ' 2>/dev/null || echo "")
            
            # Also get other feedback fields
            feedback_incorrect=$(echo "$qa" | jq -r --arg start_date "$feedback_start" '
              [.feedback[]? | select(.reaction == "downvote" and (.created_at | split("T")[0]) >= $start_date)][0].incorrect // false
            ' 2>/dev/null || echo "false")
            feedback_irrelevant=$(echo "$qa" | jq -r --arg start_date "$feedback_start" '
              [.feedback[]? | select(.reaction == "downvote" and (.created_at | split("T")[0]) >= $start_date)][0].irrelevant // false
            ' 2>/dev/null || echo "false")
            feedback_unaddressed=$(echo "$qa" | jq -r --arg start_date "$feedback_start" '
              [.feedback[]? | select(.reaction == "downvote" and (.created_at | split("T")[0]) >= $start_date)][0].unaddressed // false
            ' 2>/dev/null || echo "false")
            
            # Build JIRA issue summary
            summary="Kapa AI Answer Downvoted: ${question:0:100}"
            if [ ${#question} -gt 100 ]; then
              summary="${summary}..."
            fi
            
            # Build JIRA issue description
            description="A user downvoted a Kapa AI answer.\n\n"
            description+="*Question:* ${question}\n\n"
            description+="*Answer:* ${answer}\n\n"
            
            if [ -n "$feedback_comment" ] && [ "$feedback_comment" != "null" ] && [ "$feedback_comment" != "" ]; then
              description+="*User Feedback:*\n${feedback_comment}\n\n"
            fi
            
            if [ "$feedback_incorrect" == "true" ] || [ "$feedback_irrelevant" == "true" ] || [ "$feedback_unaddressed" == "true" ]; then
              description+="*Feedback Flags:*\n"
              [ "$feedback_incorrect" == "true" ] && description+="- Marked as incorrect\n"
              [ "$feedback_irrelevant" == "true" ] && description+="- Marked as irrelevant\n"
              [ "$feedback_unaddressed" == "true" ] && description+="- Marked as unaddressed\n"
              description+="\n"
            fi
            
            description+="*Metadata:*\n"
            description+="- Thread ID: ${thread_id}\n"
            description+="- Question Answer ID: ${question_answer_id}\n"
            
            # Create JIRA issue using REST API v3
            jira_issue=$(jq -n \
              --arg project_key "$JIRA_PROJECT_KEY" \
              --arg issue_type "$JIRA_ISSUE_TYPE" \
              --arg summary "$summary" \
              --arg description "$description" \
              '{
                fields: {
                  project: { key: $project_key },
                  summary: $summary,
                  description: {
                    type: "doc",
                    version: 1,
                    content: [{
                      type: "paragraph",
                      content: [{ type: "text", text: $description }]
                    }]
                  },
                  issuetype: { name: $issue_type }
                }
              }')
            
            # Create JIRA issue
            echo "Creating JIRA task for question: ${question:0:50}..."
            
            response=$(curl -s -w "\n%{http_code}" -X POST \
              "${JIRA_URL}/rest/api/3/issue" \
              -H "Content-Type: application/json" \
              -H "Authorization: Basic $(echo -n "${JIRA_EMAIL}:${JIRA_API_TOKEN}" | base64)" \
              -d "$jira_issue")
            
            http_code=$(echo "$response" | tail -n1)
            response_body=$(echo "$response" | sed '$d')
            
            if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
              issue_key=$(echo "$response_body" | jq -r '.key // "Unknown"')
              echo "✅ Successfully created JIRA task: $issue_key"
            else
              echo "❌ Failed to create JIRA task. HTTP $http_code"
              echo "Response: $response_body"
            fi
            
            # Small delay to avoid rate limiting
            sleep 1
          done
          
          echo "Finished processing all downvotes"

